#include <stdio.h> #include <stdlib.h> #include <stdbool.h> #include <string.h> #include "queue.c" #define MEM_SIZE 200 #define IO_TIME 4 #define MAX_TREADS 4 #define QUANTUM_TIME 3 // Intruções #define ZERO 0 #define COPY 1 #define DECR 2 #define NWTH 3 #define JFRW 4 #define JBCK 5 #define DISK 6 #define JIFZ 7 #define PRNT 8 #define JOIN 9 #define ADDX 10 #define MULX 11 #define RETN 12 #define HALT 20 #define LOAD 19 #define THRD 18 #define ENDP 17 // Erros #define SegmentationFault  0 #define InvalidVariable    1 #define InputOutputCall    2 #define PrintVariable      3 #define WaitByThread       4 #define OK                 5 #define InvalidInstruction 6 typedef struct runner Runner; typedef struct Process Process; typedef struct Program Program; // Diversos estados enum States { EXIT, PRE_EXIT, READY, RUN, BLOCKED, NONCREATE, NEW, FINISH, WBT, //waiting by thread }; struct runner{ int output; int variableId; int id_running; int quantum; int inputOutput; int instant; int newl; int readyl; int blockl; int exitl; }; struct Process{ Boolean isThread; Boolean isWaiting[MAX_TREADS]; int size; int pai; int idThread; char *tag; int id; int pc; int startIntant; int pcVars; int numVars; enum States state; int numOfthreads; int threads[MAX_TREADS]; }; struct Program{ int id; int tStart; int index; int instruction[200]; int numInstructions; int numVars; int total; int tNumInstructions; int tIndex; int tNumVars; int tTotal; }; Program programs[MEM_SIZE/2]; Process process[MEM_SIZE/2]; Runner R; Queue ready; Queue block; int numOfProcess; int numOfPrograms; int mem[MEM_SIZE]; int bit[MEM_SIZE]; int freeSpace; int lastIndex; int getMax(int maxVal, int instruction, int var){ //devolve o valor maximo entre o valor maximo atual e da instrução em analise switch(instruction){ case ZERO: case COPY: case DECR: case PRNT: case ADDX: case MULX: if(var > maxVal) return var; default: return maxVal; } } void printMemory(){             //imprime o array da memoria e o array de bits e o espaço livre for(int i =0 ; i < MEM_SIZE; i=i+1) printf("%2d ",mem[i]); for(int i =0 ; i < MEM_SIZE; ++i) printf("%2d ",bit[i]); printf("\nEspaço Livre: %3d\n",freeSpace); printf("\n\n");// } void removeProcess(int id){     //remove um processo da memoria process[id].state = FINISH; Process p = process[id]; for(int t = 0; t < p.numOfthreads; t++ ){     //remover todas as threads do process if(process[p.threads[t]].state != FINISH){ removeProcess(p.threads[t]); } } for(int i = p.startIntant; i < p.startIntant + p.size ; ++i){ mem[i] = 0; bit[i] = -1; } freeSpace += p.size; //printMemory(); } void allocate_thread(int idProgram, int idThread){  //alocar uma Thread Program p = programs[idProgram]; int segmento=-1; int pcIntructions; int pcVars; int indexFinal; boolean allocate = false; if(p.tTotal > freeSpace){   //caso não haja process[numOfProcess].state = FINISH; printf("> Erro ao alocar o TH%d do P%d espaço de memoria insuficiente\n",idThread+1,idProgram+1); return; numOfProcess++; } for(int i = lastIndex ; i < MEM_SIZE; i++){ if(bit[i] == -1){ segmento ++; if(segmento == 0){ pcIntructions = i; segmento++; } if(segmento == p.tTotal){ //printf("@%d, %d, --%d\n",lastIndex,pcIntructions,p.tTotal); lastIndex = pcIntructions + p.tTotal; pcVars = pcIntructions + p.tNumInstructions * 2; indexFinal = pcIntructions + p.tTotal; process[numOfProcess].startIntant = pcIntructions; process[numOfProcess].pc = pcIntructions; process[numOfProcess].pcVars = pcVars; process[numOfProcess].numVars = p.tNumVars; process[numOfProcess].state = READY; process[numOfProcess].tag = "TH"; process[numOfProcess].idThread = idThread; process[numOfProcess].pai = idProgram; process[numOfProcess].id = numOfProcess; process[numOfProcess].isThread = true; process[numOfProcess].size = p.tTotal; allocate = true; freeSpace -= p.tTotal; for (int j = pcIntructions, k=p.tIndex; j<indexFinal; j++,k++){ bit[j] = numOfProcess; mem[j] = p.instruction[k]; //printf("%2d %2d\n",p.instruction[k],k); } for(int j =pcVars, k = process[idProgram].pcVars; j < indexFinal ; ++j ){ bit[j] = numOfProcess; mem[j] = mem[k]; k++; } } } else{ segmento = -1; pcIntructions = -1; } } if(!allocate){ for(int i = lastIndex ; i < MEM_SIZE; i++){ if(bit[i] == -1){ segmento ++; if(segmento == 0){ pcIntructions = i; segmento++; } if(segmento == p.tTotal){ lastIndex = pcIntructions + p.tTotal; pcVars = pcIntructions + p.tNumInstructions * 2; indexFinal = pcIntructions + p.tTotal; process[numOfProcess].startIntant = pcIntructions; process[numOfProcess].pc = pcIntructions; process[numOfProcess].pcVars = pcVars; process[numOfProcess].numVars = p.tNumVars; process[numOfProcess].state = READY; process[numOfProcess].tag = "TH"; process[numOfProcess].idThread = idThread; process[numOfProcess].pai = idProgram; process[numOfProcess].id = numOfProcess; process[numOfProcess].isThread = true; process[numOfProcess].size = p.tTotal; allocate = true; freeSpace -= p.tTotal; for (int j = pcIntructions, k=0; j<indexFinal; j++,k++){ bit[j] = numOfProcess; mem[j] = p.instruction[k]; //printf("%2d %2d\n",p.instruction[k],k); } for(int j =pcVars, k = process[idProgram].pcVars; j < indexFinal ; ++j ){ bit[j] = numOfProcess; mem[j] = mem[k]; k++; } } } else{ segmento = -1; pcIntructions = -1; } } } if(allocate){ mem[process[numOfProcess].pcVars] = mem[process[idProgram].pcVars+idThread]; mem[process[numOfProcess].pcVars+1] = idThread; enqueue(numOfProcess,ready); numOfProcess++; } } void allocate(int id){ Program p = programs[id]; int k; int segmento = -1; int pcIntructions = -1; int pcVars, indexFinal; int p_size = p.total; boolean allocate; //printf("%d",p_size); if (p_size > freeSpace){ process[id].state = FINISH; printf("> Erro ao alocar o P%d espaço de memoria insuficiente\n",id+1); return; } for(int i=lastIndex; i < MEM_SIZE;i++){ if(bit[i] == -1){ segmento ++; if(segmento == 0){ pcIntructions = i; segmento++; } if(segmento == p_size){ lastIndex = pcIntructions + p_size; pcVars = pcIntructions + p.numInstructions*2; indexFinal = pcIntructions + p.total; process[id].startIntant = pcIntructions; process[id].pcVars = pcVars; process[id].numVars = p.numVars; process[id].state = NEW; process[id].tag = "P"; process[id].id = id; process[id].pc = pcIntructions; process[id].isThread = false; process[id].size = p_size; freeSpace -= p_size; //printf("%d %d %d %d \n",pcIntructions,pcVars,indexFinal,p_size); for (int j = pcIntructions, k=0; j<indexFinal; j++,k++){ bit[j] = id; mem[j] = p.instruction[k]; //printf("%2d %2d\n",p.instruction[k],k); } for(int j =pcVars; j < indexFinal ; ++j ){ bit[j] = id; mem[j] = 0; } allocate = true; if(pcIntructions >= MEM_SIZE) pcIntructions = 0; } } else{ segmento = -1; pcIntructions = -1; } } if(!allocate){ segmento = -1; pcIntructions = -1; for(int i = 0; i <MEM_SIZE; ++i){ if(bit[i] == -1){ segmento++; if(segmento == 0){ pcIntructions = i; segmento ++; } if(segmento == p_size){ lastIndex = pcIntructions + p_size; pcVars = pcIntructions + p.numInstructions*2; indexFinal = pcIntructions + p.total; process[id].startIntant = pcIntructions; process[id].pcVars = pcVars; process[id].numVars = p.numVars; process[id].state = NEW; process[id].tag = "P"; process[id].id = id; process[id].pc = pcIntructions; process[id].isThread = false; process[id].size = p_size; freeSpace -= p_size; for (int j = pcIntructions, k = 0; j < pcVars; j++,k++){ bit[j] = id; mem[j] = p.instruction[k]; } for (int j = pcVars; j < indexFinal;j++){ bit[j] = id; mem[j] = 0; } allocate = true; if(pcIntructions >= MEM_SIZE){ pcIntructions = 0; } return; } } else{ segmento = -1; pcIntructions = -1; } } } } int getInstructionID(char *instruction){ if (instruction == NULL) return -1; if (strcmp(instruction, "ZERO") == 0) return ZERO; else if (strcmp(instruction, "COPY") == 0) return COPY; else if (strcmp(instruction, "DECR") == 0) return DECR; else if (strcmp(instruction, "NWTH") == 0) return NWTH; else if (strcmp(instruction, "JFRW") == 0) return JFRW; else if (strcmp(instruction, "JBCK") == 0) return JBCK; else if (strcmp(instruction, "DISK") == 0) return DISK; else if (strcmp(instruction, "JIFZ") == 0) return JIFZ; else if (strcmp(instruction, "PRNT") == 0) return PRNT; else if (strcmp(instruction, "JOIN") == 0) return JOIN; else if (strcmp(instruction, "ADDX") == 0) return ADDX; else if (strcmp(instruction, "MULX") == 0) return MULX; else if (strcmp(instruction, "RETN") == 0) return RETN; else if (strcmp(instruction, "HALT") == 0) return HALT; else if (strcmp(instruction, "LOAD") == 0) return LOAD; else if (strcmp(instruction, "THRD") == 0) return THRD; else if (strcmp(instruction, "ENDP") == 0) return ENDP; else return -1; } void readFile( FILE  *file){ if (file == NULL) return ; int maxVal=0 , i = 0, j = -1 , nOfInstru=0; char *line; size_t size = 0; while(getline(&line,&size, file) != -1){ if(strcmp(line, "\n")!= 0){ char *instruction = strtok(line, " "); if(strcmp(instruction, "LOAD") == 0){ programs[i].tStart = atoi(strtok(NULL, " ")); } else if(strcmp(instruction, "THRD") == 0){ nOfInstru++; programs[i].numInstructions = nOfInstru; programs[i].numVars = maxVal+1; programs[i].total = programs[i].numVars + (programs[i].numInstructions) * 2; programs[i].instruction[(programs[i].numInstructions*2) -2] = THRD; maxVal = 0; nOfInstru = 0; programs[i].tIndex = j+1; programs[i].id = i; programs[i].index = 0; } else if(strcmp(instruction, "ENDP") == 0){ programs[i].tNumInstructions = nOfInstru; if (maxVal < 10) programs[i].tNumVars = maxVal; else programs[i].tNumVars = 9; programs[i].tTotal = programs[i].tNumVars + (programs[i].tNumInstructions ) * 2; maxVal = 0; nOfInstru = 0; j = -1; i++; } else{ nOfInstru ++; int intruction = getInstructionID(instruction); int var = atoi(strtok(NULL, " ")); maxVal = getMax(maxVal, intruction,var); ++j; programs[i].instruction[j] = intruction; ++j; programs[i].instruction[j]= var; } } } programs[i].numInstructions = nOfInstru; programs[i].numVars = maxVal+1; } int getNumOfPrograms(FILE *file){ char *line; size_t size; int nOProg = 0; if(file == NULL){ return -1; } while(getline(&line, &size, file)!= -1){ char *instruction = strtok(line, " "); if (strcmp(instruction, "LOAD")==0) nOProg++; } rewind(file); return nOProg; } int executeThread(int id){ //printf("TH%d",id); Process p = process[id]; Process pai = process[p.pai]; int index = p.pc; int instruction = mem[index]; int value = mem[index+1]; int dest; //printf("@%d %d, index : %d, %d",instruction,value,index,p.pcVars); if(index >= p.pcVars || index < p.startIntant){ removeProcess(id); return SegmentationFault; } switch(instruction){ case ZERO: mem[p.pcVars] = value; process[id].pc += 2; break; case COPY: if( value > 0 ||value > p.numVars){ if(value > 9){ mem[pai.pcVars + value] = mem[p.pcVars]; process[id].pc +=2; } else{ mem[p.pcVars + value] = mem[p.pcVars]; process[id].pc +=2; } } else{ removeProcess(id); return InvalidVariable; } break; case DECR: if( value > 0 || value > p.numVars){ if(value > 9){ mem[pai.pcVars + value]--; process[id].pc +=2; } else{ mem[p.pcVars + value]--; process[id].pc +=2; } } else{ removeProcess(id); return InvalidVariable; } break; case JFRW: dest = index + value*2; if(dest >= p.pcVars || dest < p.startIntant){ removeProcess(id); return SegmentationFault; } else{ process[id].pc = dest; } break; case JBCK: dest = index - value*2; if(dest >= p.pcVars || dest < p.startIntant){ removeProcess(id); return SegmentationFault; } else{ process[id].pc = dest; } break; case DISK: process[id].pc +=2; return InputOutputCall; break; case JIFZ: dest = index + 6; int memindex = value > 9 ? pai.pcVars+value : p.pcVars+value; if(mem[memindex] == 0){ if(dest >= p.pcVars || dest < p.startIntant){ removeProcess(id); return SegmentationFault; } else{ process[id].pc = dest; } } else{ process[id].pc += 2; } break; case PRNT: if(value >= 0){ process[id].pc += 2; return PrintVariable; } else{ removeProcess(id); return InvalidVariable; } break; case ADDX: if(value < 0){ return SegmentationFault; } else{ process[id].pc += 2; if(value < 9){ mem[p.pcVars] = mem[p.pcVars] + mem[p.pcVars + value]; } else{ mem[p.pcVars] = mem[p.pcVars] + mem[pai.pcVars + value]; } } break; case MULX: if(value < 0){ return SegmentationFault; } else{ process[id].pc += 2; if(value < 9){ mem[p.pcVars] = mem[p.pcVars] * mem[p.pcVars + value]; } else{ mem[p.pcVars] = mem[p.pcVars] * mem[pai.pcVars + value]; } } break; case RETN: process[id].state = FINISH; removeProcess(id); break; default: removeProcess(id); return InvalidInstruction; break; } return OK; } int executeProgram(int id){ Process p = process[id]; if (p.isThread || strcmp(p.tag,"TH") == 0){ int result = executeThread(id); return result; } int index = p.pc; int instruction = mem[index]; int value = mem[index +1]; int dest; if(index >= p.pcVars || index < p.startIntant){ removeProcess(id); return SegmentationFault; } switch(instruction){ case ZERO: mem[p.pcVars] = value; process[id].pc += 2; break; case COPY: if(value >0 || value > p.pcVars){ mem[p.pcVars + value] = mem[p.pcVars]; process[id].pc +=2; } else{ removeProcess(id); return InvalidVariable; } break; case DECR: if(value >0 || value > p.numVars){ mem[p.pcVars + value]--; process[id].pc +=2; } else{ removeProcess(id); return InvalidVariable; } break; case NWTH: if(p.numOfthreads < MAX_TREADS){ allocate_thread(id,p.numOfthreads); process[id].threads[p.numOfthreads] = numOfProcess; process[id].numOfthreads++; process[id].pc +=2; } break; case JFRW: dest = index + value *2; if(dest >= p.pcVars|| dest < p.startIntant){ removeProcess(id); return SegmentationFault; } else{ process[id].pc = dest; } break; case JBCK: dest = index - value *2; if(dest >= p.pcVars|| dest < p.startIntant){ removeProcess(id); return SegmentationFault; } else{ process[id].pc = dest; } break; case DISK: process[id].pc +=2; return InputOutputCall; break; case JIFZ: dest = index + 4; if(mem[p.pcVars+value] == 0){ if(dest >= p.pcVars || dest < p.startIntant){ removeProcess(id); return SegmentationFault; } else{ process[id].pc = dest; } } else{ process[id].pc += 2; } break; case PRNT: if(value >= 0){ process[id].pc += 2; return PrintVariable; } else{ removeProcess(id); return InvalidVariable; } break; case JOIN: process[id].pc += 2; return WaitByThread; break; case ADDX: if(value < 0) return SegmentationFault; else{ mem[p.pcVars] = mem[p.pcVars] + mem[p.pcVars+ value]; process[id].pc += 2; } break; case MULX: if(value < 0) return SegmentationFault; else{ mem[p.pcVars] = mem[p.pcVars] * mem[p.pcVars+ value]; process[id].pc +=  2; } break; case HALT: process[id].state = PRE_EXIT; break; default: return InvalidInstruction; break; } return OK; } Boolean canProced(int id){ Process p = process[id]; for(int c = 0; c < MAX_TREADS; c++){ if(p.isWaiting[c]){ if(process[p.threads[c]].state != FINISH) return false; } } return true; } void blockedtoReady(){ if(!isEmpty(block)){ if(R.inputOutput == 0){ process[peek(block)].state = READY; enqueue(dequeue(block), ready); R.inputOutput = IO_TIME; } R.inputOutput--; } } void newProcess(){ for( int i = 0; i < numOfPrograms; i++){ Process p = process[i]; if(programs[i].tStart == R.instant){ allocate(i); } } } void new2Ready(){ for( int i = 0; i < numOfPrograms; i++){ Process p = process[i]; if(p.state == NEW && programs[i].tStart != R.instant ){ enqueue(i,ready); process[i].state = READY; } else if(programs[i].tStart == R.instant){ allocate(i); } } } void run2exit_blocked_run(){ if(R.id_running !=-1){ R.quantum--; if(R.quantum == 0 && isEmpty(ready)){ R.quantum++; } if(R.quantum == 0){ enqueue(R.id_running,ready); process[R.id_running].state = READY; R.id_running = -1; } else{ R.variableId = executeProgram(R.id_running); if( R.variableId == PrintVariable){ int var = mem[process[R.id_running].pc-1]; if(process[R.id_running].isThread){ if(var >9){ int pos = process[process[R.id_running].pai].pcVars + var; R.output = mem[pos]; } else{ R.output = mem[process[R.id_running].pcVars+var]; } } else{ R.output = mem[process[R.id_running].pcVars+var]; } } } } } void ready2run(){ if(R.id_running == -1 && !isEmpty(ready)){ R.id_running = dequeue(ready); R.quantum = QUANTUM_TIME; process[R.id_running].state = RUN; R.variableId = executeProgram(R.id_running); if( R.variableId == PrintVariable){ int var = mem[process[R.id_running].pc-1]; if(process[R.id_running].isThread){ if(var >9){ int pos = process[process[R.id_running].pai].pcVars + var; R.output = mem[pos]; } else{ R.output = mem[process[R.id_running].pcVars+var]; } } else{ R.output = mem[process[R.id_running].pcVars+var]; } } } } void exit2finish(){ for(int i = 0; i< numOfPrograms; i++){ if(process[i].state == EXIT){ removeProcess(i); process[i].state == FINISH; } if(process[i].state == PRE_EXIT){ process[i].state = EXIT; R.id_running = -1; } } } void runner(){ R.variableId = -1; R.id_running=-1; R.quantum = QUANTUM_TIME; R.inputOutput = IO_TIME; R.instant=0; R.newl = 6; R.readyl = 13; R.blockl = 15; R.exitl = 8; printf("|   T   |NEW   |READY        | RUN |BLOCK          |EXIT    |\n"); int l = 0; newProcess(); printf("| %3d   |",R.instant); for(int i = 0; i < numOfPrograms;++i){ if(process[i].state == NEW){ printf("%s%d ",process[i].tag,i+1); if(process[i].id <= 9) l += 3; else l += 4; } } for(l;l<R.newl;l++){ printf(" "); } printf("|             |     |               |        |\n"); while(true){ R.variableId = 0; R.instant ++; blockedtoReady(); exit2finish(); run2exit_blocked_run(); new2Ready(); ready2run(); newProcess(); l = 0; printf("| %3d   |",R.instant); for( int i = 0; i < numOfPrograms; i++){ Process p = process[i]; if(process[i].state == NEW){ printf("%s%d ",process[i].tag,i+1); if(p.id <= 9) l += 3; else l += 4; } } for(l;l<R.newl;l++){ printf(" "); } printf("|"); l= 0; Node aux = ready->front; while(aux != NULL){ Process p = process[aux->element]; if(p.isThread) printf("%s%d ",p.tag,p.idThread+1); else printf("%s%d ",p.tag,p.id+1); if(strcmp(p.tag,"TH") == 0){ if(p.id <= 9) l += 4; else l += 5; } else{ if(p.id <= 9) l += 3; else l += 4; } aux = aux->next; } for(l;l<R.readyl;l++){ printf(" "); } printf("|"); if(R.id_running == -1){ printf("     |"); } else{ Process p = process[R.id_running]; if(strcmp(p.tag,"TH") == 0){ if(p.id <= 9) printf(" %s%d |",p.tag,p.idThread+1); else printf("%s%d |",p.tag,p.idThread+1); } else{ if(p.id <= 9) printf(" %s%d  |",p.tag,p.id+1); else printf(" %s%d |",p.tag,p.id+1); } } l = 0; aux = block->front; while(aux != NULL){ Process p = process[aux->element]; if(p.isThread) printf("%s%d ",p.tag,p.idThread+1); else printf("%s%d ",p.tag,p.id+1); if(strcmp(p.tag,"TH") == 0){ if(p.id <= 9) l += 4; else l += 5; } else{ if(p.id <= 9) l += 3; else l += 4; } aux = aux->next; } int wb = 0; while(wb < numOfPrograms){ Process p = process[wb]; if(p.state == WBT){ printf("%s%d ",p.tag,p.id+1); if(p.id <= 9) l += 3; else l += 4; } wb++; } for(l; l<R.blockl;++l){ printf(" "); } printf("|"); l = 0; for( int i = 0; i < numOfPrograms;i++){ if(process[i].state==EXIT ){ printf("P%d ",i+1); if(i < 9) l += 3; else l += 4; } } for(l ;l < R.exitl; l++){ printf(" "); } printf("|\n"); if(process[R.id_running].state == PRE_EXIT){ R.id_running = -1; } if(R.variableId == PrintVariable){ printf(">Print %d \n",R.output); } if(R.variableId == InputOutputCall){ process[R.id_running].state = BLOCKED; enqueue(R.id_running,block); R.id_running = -1; } if (R.variableId == WaitByThread){ int thread = mem[process[R.id_running].pc-1]; process[R.id_running].isWaiting[thread-1] = true; process[R.id_running].state = WBT; R.id_running = -1; } if( R.variableId == SegmentationFault){ if(R.id_running != -1){ if(process[R.id_running].isThread){ Process p = process[R.id_running]; printf("> Segmentation Error in TH%d of P%d\n",p.idThread, p.pai+1); process[p.pai].isWaiting[p.idThread] = false; } else{ printf("> Segmentation Error in P%d\n",R.id_running+1); } R.id_running = -1; } } if( R.variableId == InvalidVariable){ if(R.id_running != -1){ if(process[R.id_running].isThread){ Process p = process[R.id_running]; printf("> Invalid Variable in TH%d of P%d\n",p.idThread,p.pai+1); } else{ printf("> Invalid Variable in P%d\n",R.id_running); } R.id_running = -1; } } if(process[R.id_running].isThread){ Process p = process[R.id_running]; if(p.state == FINISH){ process[p.pai].isWaiting[p.idThread] = false; R.id_running = -1; } } for(int c = 0; c < numOfPrograms; c++){ if(process[c].state == WBT && canProced(c)){ process[c].state = READY; enqueue(c,ready); } } int nOfProgramsRunning = 0; for(int i = 0; i < numOfPrograms; i++){ if(process[i].state != FINISH){ nOfProgramsRunning++; } } if(nOfProgramsRunning == 0) break; if(R.instant == 100) break; } } void main(){ char *path = "input4.txt"; FILE *file = fopen(path, "r"); if(file ==NULL){ printf("Não foi possivel abrir o fichero!\n"); return; } else{ printf("Ficheiro aberto com sucesso!\n"); } numOfPrograms = getNumOfPrograms(file); numOfProcess = numOfPrograms; readFile(file); freeSpace = MEM_SIZE; lastIndex = -1; for(int i =0 ; i < 200; ++i){ mem[i] = 0; bit[i] = -1; } ready = inicializeQueue(); block = inicializeQueue(); runner(); }